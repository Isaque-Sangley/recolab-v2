"""
Ratings Router

Endpoints relacionados a avalia√ß√µes (CRUD completo).
"""

from typing import List

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field

from ...application.dtos import (
    CreateRatingRequest,
    DeleteRatingRequest,
    RatingDTO,
    UpdateRatingRequest,
)
from ...application.services import RatingApplicationService, RecommendationApplicationService
from ..dependencies import get_rating_service, get_recommendation_service

router = APIRouter(prefix="/ratings", tags=["ratings"])


# Pydantic models para request/response
class CreateRatingBody(BaseModel):
    """Body para criar rating"""

    user_id: int = Field(..., description="User ID")
    movie_id: int = Field(..., description="Movie ID")
    score: float = Field(
        ..., ge=0.5, le=5.0, description="Rating score (0.5-5.0, increments of 0.5)"
    )

    class Config:
        json_schema_extra = {"example": {"user_id": 1, "movie_id": 123, "score": 4.5}}


@router.post("/", response_model=RatingDTO, status_code=status.HTTP_201_CREATED)
async def create_rating(
    body: CreateRatingBody,
    rating_service: RatingApplicationService = Depends(get_rating_service),
    recommendation_service: RecommendationApplicationService = Depends(get_recommendation_service),
):
    """
    ‚≠ê **CRIAR RATING**

    Cria novo rating (avalia√ß√£o de usu√°rio para filme).

    Use case: Usu√°rio avalia um filme pela primeira vez.

    Side effects:
    - Atualiza estat√≠sticas do usu√°rio (n_ratings, avg_rating)
    - Atualiza estat√≠sticas do filme (rating_count, avg_rating)
    - Invalida cache de recomenda√ß√µes
    - Publica evento RatingCreated (para analytics)

    Args:
        body: dados do rating (user_id, movie_id, score)

    Returns:
        RatingDTO criado

    Example:
        POST /api/v1/ratings/
        {
            "user_id": 1,
            "movie_id": 123,
            "score": 4.5
        }
    """
    request = CreateRatingRequest(user_id=body.user_id, movie_id=body.movie_id, score=body.score)

    try:
        rating = await rating_service.create_rating(request)

        # Invalida cache de recomenda√ß√µes do usu√°rio
        await recommendation_service.invalidate_user_cache(body.user_id)

        return rating

    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/", response_model=RatingDTO)
async def update_rating(
    user_id: int = Query(..., description="User ID"),
    movie_id: int = Query(..., description="Movie ID"),
    score: float = Query(..., ge=0.5, le=5.0, description="New rating score (0.5-5.0)"),
    rating_service: RatingApplicationService = Depends(get_rating_service),
    recommendation_service: RecommendationApplicationService = Depends(get_recommendation_service),
):
    """
    üîÑ **ATUALIZAR RATING**

    Atualiza o rating de um usu√°rio para um filme.

    Use case: Usu√°rio muda sua avalia√ß√£o de um filme.

    Args:
        user_id: ID do usu√°rio
        movie_id: ID do filme
        score: Nova nota (0.5 a 5.0, incrementos de 0.5)

    Returns:
        RatingDTO atualizado

    Example:
        PUT /api/v1/ratings/?user_id=1&movie_id=123&score=5.0
    """
    request = UpdateRatingRequest(user_id=user_id, movie_id=movie_id, score=score)

    try:
        rating = await rating_service.update_rating(request)

        if not rating:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Rating not found for user {user_id} and movie {movie_id}",
            )

        # Invalida cache
        await recommendation_service.invalidate_user_cache(user_id)

        return rating

    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/")
async def delete_rating(
    user_id: int = Query(..., description="User ID"),
    movie_id: int = Query(..., description="Movie ID"),
    rating_service: RatingApplicationService = Depends(get_rating_service),
    recommendation_service: RecommendationApplicationService = Depends(get_recommendation_service),
):
    """
    üóëÔ∏è **DELETAR RATING**

    Remove o rating de um usu√°rio para um filme.

    Use case: Usu√°rio quer remover sua avalia√ß√£o.

    Args:
        user_id: ID do usu√°rio
        movie_id: ID do filme

    Returns:
        Mensagem de confirma√ß√£o

    Example:
        DELETE /api/v1/ratings/?user_id=1&movie_id=123
    """
    request = DeleteRatingRequest(user_id=user_id, movie_id=movie_id)

    try:
        success = await rating_service.delete_rating(request)

        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Rating not found for user {user_id} and movie {movie_id}",
            )

        # Invalida cache
        await recommendation_service.invalidate_user_cache(user_id)

        return {
            "message": "Rating deleted successfully",
            "user_id": user_id,
            "movie_id": movie_id,
            "status": "deleted",
        }

    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/user/{user_id}", response_model=List[RatingDTO])
async def get_user_ratings(
    user_id: int,
    limit: int = Query(100, le=500, description="Max results"),
    service: RatingApplicationService = Depends(get_rating_service),
):
    """
    Lista todos os ratings de um usu√°rio.

    Args:
        user_id: ID do usu√°rio
        limit: limite de resultados (max 500)

    Returns:
        Lista de RatingDTO
    """
    ratings = await service.get_user_ratings(user_id, limit)
    return ratings


@router.get("/movie/{movie_id}", response_model=List[RatingDTO])
async def get_movie_ratings(
    movie_id: int,
    limit: int = Query(100, le=500, description="Max results"),
    service: RatingApplicationService = Depends(get_rating_service),
):
    """
    Lista todos os ratings de um filme.

    Args:
        movie_id: ID do filme
        limit: limite de resultados (max 500)

    Returns:
        Lista de RatingDTO
    """
    ratings = await service.get_movie_ratings(movie_id, limit)
    return ratings


@router.get("/{user_id}/{movie_id}", response_model=RatingDTO)
async def get_rating(
    user_id: int, movie_id: int, service: RatingApplicationService = Depends(get_rating_service)
):
    """
    Obt√©m rating espec√≠fico (user + movie).

    Args:
        user_id: ID do usu√°rio
        movie_id: ID do filme

    Returns:
        RatingDTO
    """
    rating = await service.get_rating(user_id, movie_id)

    if not rating:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Rating not found")

    return rating


@router.get("/stats/overview")
async def get_rating_stats(service: RatingApplicationService = Depends(get_rating_service)):
    """
    üìä **ESTAT√çSTICAS GERAIS**

    Estat√≠sticas gerais de ratings do sistema.

    Returns:
        Dict com estat√≠sticas:
        - total_ratings: n√∫mero total de avalia√ß√µes
        - unique_users: usu√°rios √∫nicos
        - unique_movies: filmes √∫nicos
        - avg_rating: m√©dia global
        - rating_distribution: distribui√ß√£o por estrelas
        - most_rated_movies: top filmes mais avaliados
        - most_active_users: top usu√°rios mais ativos
    """
    stats = await service.get_rating_stats()
    return stats
